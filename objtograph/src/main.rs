//! Utility for creating METIS-compatible graph files from Wavefront OBJ files
//!
//! OBJ files are plentiful, so this is nice to have. We only parse the simplist of obj files and
//! there's next to no error handling, but it's not needed for the most part since the obj files
//! you find in the real world are autogenerated and don't use next to none of the features that
//! are ostensibly in the spec
//!
//! See: https://paulbourke.net/dataformats/obj/ for the more full spec

use std::{collections::BTreeMap, ffi::OsString, io::{self, prelude::*, BufReader, BufWriter}, path::PathBuf, process::ExitCode, time::Instant};

mod util;
mod obj;
mod mtx;
mod parser;
mod edges;

// const BUF_RW_CAPACITY: usize = 1024 * 1024 * 2;
const BUF_RW_CAPACITY: usize = 1024 * 2;

fn invalid_format() -> io::Error {
    io::Error::new(io::ErrorKind::Other, "Invalid format")
}

#[allow(non_camel_case_types)]
type idx_t = u32;
fn idx_t<'a>() -> impl parser::Parser<'a, Out = idx_t> {
    parser::u32()
}

fn print_usage() {
    let name = std::env::current_exe().unwrap_or_else(|_| "objtograph".into());
    let name = name.display();
    eprintln!("usage: {name} <PATH>");
}

fn get_path() -> Option<OsString> {
    let mut args = std::env::args_os();
    let len = args.len();
    if len < 2 || len > 3 {
        return None
    }
    let _ = args.next(); // executable
    if len == 3 {
        // 3 args means the next is `--`
        if args.next()? != "--" {
            return None
        }
    }
    let path = args.next()?;

    // interpret flags if there wasn't a `--`
    if (path == "-h" || path == "--help") && len != 3 {
        return None
    }

    Some(path)
}

#[inline(never)]
fn print_fatal_error(msg: &dyn std::fmt::Display) {
    eprintln!("FATAL: {msg}")
}

fn main() -> ExitCode {
    let Some(path) = get_path() else {
        print_usage();
        return ExitCode::FAILURE
    };
    let mut path = PathBuf::from(path);
    if path.file_name().is_none() {
        print_fatal_error(&"directories are not valid files");
        return ExitCode::FAILURE;
    }

    let Some(ext) = path.extension() else {
        print_fatal_error(&"don't know what file type (determine exclusively by extension)");
        return ExitCode::FAILURE
    };

    let start_time = Instant::now();

    let mut edges = {
        let r = match std::fs::OpenOptions::new().read(true).open(&path) {
            Ok(f) => BufReader::with_capacity(BUF_RW_CAPACITY, f),
            Err(e) => {
                print_fatal_error(&e);
                return ExitCode::FAILURE;
            },
        };


        let res = match ext.to_str() {
            Some("obj") => obj::edges(r),
            Some("mtx") => mtx::edges(r),
            Some("edges") => edges::edges(r),
            _ => {
                print_fatal_error(&format_args!("Unknown extension: {ext:?}"));
                return ExitCode::FAILURE
            },
        };

        match res {
            Ok(e) => e,
            Err(e) => {
                print_fatal_error(&e);
                return ExitCode::FAILURE;
            },
        }
    };

    eprintln!("parse in {}ms", start_time.elapsed().as_millis());


    if edges.is_empty() {
        print_fatal_error(&"graph has no edges");
        return ExitCode::FAILURE;
    }

    path.set_extension("graph");
    let path = path.file_name().expect("previously checked that there is a file name");

    let f = match std::fs::OpenOptions::new().write(true).create(true).truncate(true).open(path) {
        Ok(f) => f,
        Err(e) => {
            print_fatal_error(&e);
            return ExitCode::FAILURE;
        },
    };

    let fixup_start = Instant::now();

    edges.sort_unstable();
    edges.dedup();
    let nvtxs = nvtxs_of_edges(&edges);
    eliminate_gaps(&mut edges, nvtxs);

    eprintln!("fixup in {}ms", fixup_start.elapsed().as_millis());

    let write_start = Instant::now();
    if let Err(e) = write_graph(BufWriter::with_capacity(BUF_RW_CAPACITY, f), &edges, nvtxs) {
        print_fatal_error(&e);
        return ExitCode::FAILURE;
    }
    eprintln!("write in {}ms", write_start.elapsed().as_millis());
    eprintln!("written to {path}", path = path.display());

    eprintln!("nvtxs:  {nvtxs:>6}");
    eprintln!("nedges: {nedges:>6}", nedges = edges.len()/2);

    return ExitCode::SUCCESS;
}

fn write_graph(mut w: impl Write, e: &[(idx_t, idx_t)], nvtxs: usize) -> io::Result<()> {
    debug_assert_eq!(nvtxs_of_edges(e), nvtxs);
    assert!(e.len() % 2 == 0, "every edge should have a back edge");
    writeln!(w, "{nvtxs} {nedges}", nedges = e.len() / 2)?;
    for vtxs in e.chunk_by(|e1, e2| e1.0 == e2.0) {
        assert!(!vtxs.is_empty());
        // The graph files themselves use 1-index edges
        write!(w, "{}", vtxs[0].1 + 1)?;
        for &(_, e2) in &vtxs[1..] {
            write!(w, " {}", e2 + 1)?;
        }
        writeln!(w)?;
    }
    w.flush()
}

fn nvtxs_of_edges(e: &[(idx_t, idx_t)]) -> usize {
    debug_assert!(e.is_sorted());
    e.chunk_by(|e1, e2| e1.0 == e2.0).count()
}

/// assumes that `forall (v0, v1) in e, (v1, v0) in e` and that `e` is sorted
fn eliminate_gaps(e: &mut [(idx_t, idx_t)], nvtxs: usize) {
    debug_assert_eq!(nvtxs_of_edges(e), nvtxs);
    if e.is_empty() {
        return
    }
    let max = e.last().unwrap().0 as usize;
    if max == nvtxs {
        // there are no gaps
        return
    }
    // unbenchmarked heuristic for if we should use a Vec or a BTree to keep track of indices
    if max < nvtxs * (64 / size_of::<idx_t>()).clamp(2, 16) || max < 1024 {
        let mut map = vec![0; max + 1];
        let mut cnt = 1;
        let mut last_mapped = e[0].0;
        for (v, _) in &mut *e {
            if last_mapped < *v {
                map[*v as usize] = cnt;
                last_mapped = *v;
                cnt += 1;
            }
            *v = cnt - 1;
        }
        assert_eq!(cnt as usize, nvtxs);
        for (_, v) in e {
            *v = map[*v as usize];
        }
    } else {
        let mut map = BTreeMap::new();
        let mut cnt = 1;
        let mut last_mapped = e[0].0;
        map.insert(e[0].0, 0);
        for (v, _) in &mut *e {
            if last_mapped < *v {
                map.insert(*v, cnt);
                last_mapped = *v;
                cnt += 1;
            }
            *v = cnt - 1;
        }
        assert_eq!(cnt as usize, nvtxs);
        for (_, v) in e {
            *v = map[&*v];
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// put a graph into a format that most functions expect
    fn norm_graph(e: impl IntoIterator<Item = (idx_t, idx_t)>) -> Vec<(idx_t, idx_t)> {
        fn inner(mut e: Vec<(idx_t, idx_t)>) -> Vec<(idx_t, idx_t)> {
            e.retain(|e| e.0 != e.1);
            e.extend_from_within(..);
            let part = e.len()/2;
            for e in &mut e[part..] {
                std::mem::swap(&mut e.0, &mut e.1);
            }
            e.sort_unstable();
            e.dedup();
            e
        }

        inner(e.into_iter().collect())
    }


    #[test]
    fn test_elim_gaps_small() {
        let mut graph = norm_graph([(1, 4), (10, 1), (42, 1), (36, 42)]);
        let nvtxs = nvtxs_of_edges(&graph);
        eliminate_gaps(&mut graph, nvtxs);
        assert_eq!(graph, [(0, 1), (0, 2), (0, 4), (1, 0), (2, 0), (3, 4), (4, 0), (4, 3)]);
    }

    #[test]
    fn test_elim_gaps_large() {
        let mut graph = norm_graph([(1, 4), (10, 1), (42, 1), (36, 42)]);
        for e in &mut graph {
            e.0 *= 8000;
            e.1 *= 8000;
        }
        let nvtxs = nvtxs_of_edges(&graph);
        eliminate_gaps(&mut graph, nvtxs);
        assert_eq!(graph, [(0, 1), (0, 2), (0, 4), (1, 0), (2, 0), (3, 4), (4, 0), (4, 3)]);
    }
}
